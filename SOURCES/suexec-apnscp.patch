diff -Nur httpd-2.4.29-orig/support/suexec.c httpd-2.4.29/support/suexec.c
--- httpd-2.4.29-orig/support/suexec.c	2016-03-21 08:37:25.000000000 -0400
+++ httpd-2.4.29/support/suexec.c	2017-11-01 16:02:13.532419132 -0400
@@ -70,6 +70,7 @@
 
 extern char **environ;
 static FILE *log = NULL;
+static char *site_root = NULL;
 
 static const char *const safe_env_lst[] =
 {
@@ -95,6 +96,8 @@
     "LAST_MODIFIED=",
     "PATH_INFO=",
     "PATH_TRANSLATED=",
+    "PYTHONPATH=",
+    "PERL5LIB=",
     "QUERY_STRING=",
     "QUERY_STRING_UNESCAPED=",
     "REMOTE_ADDR=",
@@ -123,6 +126,7 @@
     "SERVER_PROTOCOL=",
     "SERVER_SIGNATURE=",
     "SERVER_SOFTWARE=",
+    "SITE_ROOT=",
     "UNIQUE_ID=",
     "USER_NAME=",
     "TZ=",
@@ -136,23 +140,60 @@
 static void err_output(int is_error, const char *fmt, va_list ap) 
     __attribute__((format(printf,2,0)));
 
-static void err_output(int is_error, const char *fmt, va_list ap)
+static void log_close()
 {
-#ifdef AP_LOG_EXEC
-    time_t timevar;
-    struct tm *lt;
+    if (log == NULL) {
+      return;
+    }
+    /* Be sure to close the log file so the CGI can't mess with it. */
+#if APR_HAVE_FCNTL_H
+    /*
+     * ask fcntl(2) to set the FD_CLOEXEC flag on the log file,
+     * so it'll be automagically closed if the exec() call succeeds.
+     */
+    fflush(log);
+    setbuf(log, NULL);
+    if ((fcntl(fileno(log), F_SETFD, FD_CLOEXEC) == -1)) {
+        log_err("error: can't set close-on-exec flag");
+        exit(122);
+    }
+#else
+    /*
+     * In this case, exec() errors won't be logged because we have already
+     * dropped privileges and won't be able to reopen the log file.
+     */
+    fclose(log);
+    log = NULL;
+#endif
+}
 
-    if (!log) {
+static void log_open()
+{
+    if (log != NULL) {
+      // @todo make warning?
+      return;
+    }
+    /** 
+     * When working with a jailed environment, rtd context
+     * will change. Always reopen log when emitting message.
+     */
 #if defined(_LARGEFILE64_SOURCE) && HAVE_FOPEN64
-        if ((log = fopen64(AP_LOG_EXEC, "a")) == NULL) {
+    if ((log = fopen64(AP_LOG_EXEC, "a")) == NULL) {
 #else
-        if ((log = fopen(AP_LOG_EXEC, "a")) == NULL) {
+    if ((log = fopen(AP_LOG_EXEC, "a")) == NULL) {
 #endif
-            fprintf(stderr, "suexec failure: could not open log file\n");
-            perror("fopen");
-            exit(1);
-        }
+        fprintf(stderr, "suexec failure: could not open log file\n");
+        perror("fopen");
+        exit(1);
     }
+}
+
+static void err_output(int is_error, const char *fmt, va_list ap)
+{
+#ifdef AP_LOG_EXEC
+    time_t timevar;
+    struct tm *lt;
+    log_open();
 
     if (is_error) {
         fprintf(stderr, "suexec policy violation: see suexec log for more "
@@ -167,8 +208,6 @@
             lt->tm_hour, lt->tm_min, lt->tm_sec);
 
     vfprintf(log, fmt, ap);
-
-    fflush(log);
 #endif /* AP_LOG_EXEC */
     return;
 }
@@ -336,12 +375,12 @@
      */
 #ifdef _OSD_POSIX
     /* User name comparisons are case insensitive on BS2000/OSD */
-    if (strcasecmp(AP_HTTPD_USER, pw->pw_name)) {
+    if (pw->pw_uid > 0 && strcasecmp(AP_HTTPD_USER, pw->pw_name)) {
         log_err("user mismatch (%s instead of %s)\n", pw->pw_name, AP_HTTPD_USER);
         exit(103);
     }
 #else  /*_OSD_POSIX*/
-    if (strcmp(AP_HTTPD_USER, pw->pw_name)) {
+    if (pw->pw_uid > 0 && strcmp(AP_HTTPD_USER, pw->pw_name)) {
         log_err("user mismatch (%s instead of %s)\n", pw->pw_name, AP_HTTPD_USER);
         exit(103);
     }
@@ -366,7 +405,6 @@
      */
     if (!strncmp("~", target_uname, 1)) {
         target_uname++;
-        userdir = 1;
     }
 
     /*
@@ -433,25 +471,76 @@
     }
 #endif /*_OSD_POSIX*/
 
+    if (getcwd(cwd, AP_MAXPATH) == NULL) {
+        log_err("emerg: cannot get current working directory\n");
+        exit(111);
+    }
+
+    /*
+     * Chroot if SITE_ROOT is set
+     * FastCGI requests do not pass SetEnv
+     * vars from Apache
+     */
+    if (0 != (site_root = (char*)getenv("SITE_ROOT"))) {
+        char *tmp;
+        if (strncmp(cwd, site_root, strlen(site_root)) != 0 ||
+        (*(tmp = cwd + strlen(site_root)) && *tmp  != '/')) {
+            log_err("error: working directory not in site root: (%s) (%s)\n", cwd, site_root);  
+            exit(122);
+        }
+        /*
+         * passwd/group db reopened once jailed
+         */
+        endpwent();
+        endgrent();
+
+        if (chroot(site_root) != 0) {
+            log_err("error: cannot chroot to site root: (%s)\n", site_root);
+            exit(122);
+        } 
+        /*
+         * Force log closure to reopen in jail
+         */
+        log_close(); 
+        if (!strncmp("/home", cwd, 5)) {
+            char *user;
+            char *p = strstr(cwd + 1, "/");
+            int len = p - cwd - 2;
+            user = strndup(cwd+6, len);
+            pw = getpwnam(user);
+            if (pw == NULL) {
+              log_err("crit: user (%s) UID invalid in site root: (%d)\n", user, uid);
+              exit(102);
+            }
+            uid = pw->pw_uid;
+            sprintf(target_uname, "%d", uid);
+            userdir = 1;
+        } else if (NULL == (pw = getpwuid(uid))) {
+            log_err("crit: UID invalid in site root: (%d)\n", uid);
+            exit(102);
+        }
+    }
+
     /*
      * Save these for later since initgroups will hose the struct
      */
     uid = pw->pw_uid;
     actual_uname = strdup(pw->pw_name);
     target_homedir = strdup(pw->pw_dir);
+    
     if (actual_uname == NULL || target_homedir == NULL) {
         log_err("failed to alloc memory\n");
         exit(126);
     }
-
+    
     /*
      * Log the transaction here to be sure we have an open log
      * before we setuid().
      */
-    log_no_err("uid: (%s/%s) gid: (%s/%s) cmd: %s\n",
+    log_no_err("uid: (%s/%s) gid: (%s/%s) cmd: %s/%s\n",
                target_uname, actual_uname,
                target_gname, actual_gname,
-               cmd);
+               cwd, cmd);
 
     /*
      * Error out if attempt is made to execute as root or as
@@ -498,14 +587,13 @@
      * Use chdir()s and getcwd()s to avoid problems with symlinked
      * directories.  Yuck.
      */
-    if (getcwd(cwd, AP_MAXPATH) == NULL) {
+    if (!site_root && getcwd(cwd, AP_MAXPATH) == NULL) {
         log_err("cannot get current working directory\n");
         exit(111);
     }
 
     if (userdir) {
         if (((chdir(target_homedir)) != 0) ||
-            ((chdir(AP_USERDIR_SUFFIX)) != 0) ||
             ((getcwd(dwd, AP_MAXPATH)) == NULL) ||
             ((chdir(cwd)) != 0)) {
             log_err("cannot get docroot information (%s)\n", target_homedir);
@@ -521,7 +609,7 @@
         }
     }
 
-    if ((strncmp(cwd, dwd, strlen(dwd))) != 0) {
+    if (!userdir && (strncmp(cwd, dwd, strlen(dwd))) != 0) {
         log_err("command not in docroot (%s/%s)\n", cwd, cmd);
         exit(114);
     }
@@ -537,7 +625,8 @@
     /*
      * Error out if cwd is writable by others.
      */
-    if ((dir_info.st_mode & S_IWOTH) || (dir_info.st_mode & S_IWGRP)) {
+    if (((dir_info.st_gid != gid) && (dir_info.st_mode & S_IWGRP))
+        || (dir_info.st_mode & S_IWOTH)) {
         log_err("directory is writable by others: (%s)\n", cwd);
         exit(116);
     }
@@ -570,15 +659,15 @@
      * Error out if the target name/group is different from
      * the name/group of the cwd or the program.
      */
-    if ((uid != dir_info.st_uid) ||
-        (gid != dir_info.st_gid) ||
-        (uid != prg_info.st_uid) ||
-        (gid != prg_info.st_gid)) {
-        log_err("target uid/gid (%lu/%lu) mismatch "
-                "with directory (%lu/%lu) or program (%lu/%lu)\n",
-                (unsigned long)uid, (unsigned long)gid,
+    if ((gid != dir_info.st_gid) ||
+        (dir_info.st_gid != prg_info.st_gid) ||
+        ((uid != prg_info.st_uid) &&
+        (dir_info.st_uid != prg_info.st_uid))) {
+        log_err("program (%ld/%ld) mismatch "
+                "with directory (%lu/%lu) or account (%ld)\n",
+                (unsigned long)prg_info.st_uid, (unsigned long)prg_info.st_gid,
                 (unsigned long)dir_info.st_uid, (unsigned long)dir_info.st_gid,
-                (unsigned long)prg_info.st_uid, (unsigned long)prg_info.st_gid);
+                (unsigned long)gid);
         exit(120);
     }
     /*
@@ -602,29 +691,7 @@
     umask(AP_SUEXEC_UMASK);
 #endif /* AP_SUEXEC_UMASK */
 
-    /* Be sure to close the log file so the CGI can't mess with it. */
-    if (log != NULL) {
-#if APR_HAVE_FCNTL_H
-        /*
-         * ask fcntl(2) to set the FD_CLOEXEC flag on the log file,
-         * so it'll be automagically closed if the exec() call succeeds.
-         */
-        fflush(log);
-        setbuf(log, NULL);
-        if ((fcntl(fileno(log), F_SETFD, FD_CLOEXEC) == -1)) {
-            log_err("error: can't set close-on-exec flag");
-            exit(122);
-        }
-#else
-        /*
-         * In this case, exec() errors won't be logged because we have already
-         * dropped privileges and won't be able to reopen the log file.
-         */
-        fclose(log);
-        log = NULL;
-#endif
-    }
-
+    log_close();
     /*
      * Execute the command, replacing our image with its own.
      */
